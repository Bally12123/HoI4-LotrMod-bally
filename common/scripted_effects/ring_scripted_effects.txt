




# Adds the current scope as a member of the fellowship
ring_add_member_to_fellowship = {

	add_to_array = { global.fs_eventlog_targets = THIS }
	add_to_array = { global.fs_eventlog = token:fs_event_member_joins }

	# Set this characters starting HP
	THIS = { set_variable = { health = army_defense_level } }

	add_to_array = { global.fs_members = THIS }
}


# Adds the current scope as a member of the hunting party of the previous scope
ring_add_member_to_hunting_party = {

	# Set this characters starting HP
	THIS = { set_variable = { health = army_defense_level } }

	add_to_array = { ROOT.fs_hunting_party = THIS }
}


# Adds the current scope as a member of the fellowship, but does NOT log this to the eventlog
ring_add_member_to_fellowship_nolog = {

	add_to_array = { global.fs_members = THIS }
}


# Removes the current scope from the fellowship
ring_remove_member_from_fellowship = {

	add_to_array = { global.fs_eventlog_targets = THIS }
	add_to_array = { global.fs_eventlog = token:fs_event_member_leaves }
	
	remove_from_array = { global.fs_members = THIS }
}


# Removes the current scope from the fellowship, but does NOT log this to the eventlog
ring_remove_member_from_fellowship_nolog = {

	remove_from_array = { global.fs_members = THIS }
}


ring_remove_member_from_hunting_party = {

	remove_from_array = { ROOT.fs_hunting_party = THIS }
}



# Clears all members from the fellowship, does NOT add an entry to the eventlog
ring_clear_fellowship_members = {

	log = "FELLOWSHIP CLEARED"

	clear_array = global.fs_members
}


# Adds an entry to the eventlog stating that the fellowship has arrived in the current scope
ring_log_arrived_in_new_state = {

	add_to_array = { global.fs_eventlog_targets = THIS }
	add_to_array = { global.fs_eventlog = token:fs_event_arrive_in_new_state }
}


# Queues up an event to move into the next state (fs.1000)
ring_fellowship_begin_move_to_next_state = {

	# TODO: Set this variable based on the speed of the fellowship
	set_variable = { global.fs_days_left_in_state = 3 }
}


# Runs every day. Pls keep as simple as possible for best performance
# Note to self: Maybe make this a weekly update instead?
ring_daily_update = {

	if = {

		# Update fs_days_left_in_state
		limit = { check_variable = { global.fs_days_left_in_state > 0 } }
		subtract_from_variable = { global.fs_days_left_in_state = 1 }

		# When the timer runs out, move fellowship to the enxt state
		if = {
			limit = { check_variable = { global.fs_days_left_in_state = 0 } }

			# This event moves the fellowship to the enxt state
			SHI = { country_event = fs.1000 }

			# Set the days remaining to negative, so that we don't accidentally call this again
			set_variable = { global.fs_days_left_in_state = -1 }
		}
	}
}


# Executes an interception attempt by the current scope
ring_execute_interception_attempt = {

	set_temp_variable = { fs_interception_cancelled = 0 }

	ring_interception_detection_check = yes

	if = {
		limit = { check_variable = { fs_interception_cancelled = 0 } }

		log = "EXECUTING INTERCEPTION ATTEMPTS"

		# Run a total of 3 attempts at taking the ring
		for_loop_effect = {
		    end = 3
		    value = temp_attempt

		    ring_interception_single_attempt = yes
		}
	}
}


# Before being able to intercept the ring, we must first successfully locate the fellowship
ring_interception_detection_check = {

	# Calculate average fellowship stealth skill (planning_skill)
	set_temp_variable = { temp_avg_fs_stealth = 0 }
	for_each_scope_loop = {
	    array = global.fs_members
	    
	    add_to_temp_variable = { temp_avg_fs_stealth = planning_level }
	}
	divide_temp_variable = { temp_avg_fs_stealth = global.fs_members^num }

	# Calculate the average stealth skill of the hunting party
	set_temp_variable = { temp_avg_hp_stealth = 0 }
	for_each_scope_loop = {
	    array = ROOT.fs_hunting_party
	    
	    add_to_temp_variable = { temp_avg_hp_stealth = planning_level }
	}
	divide_temp_variable = { temp_avg_hp_stealth = ROOT.fs_hunting_party^num }
	# Hunting party gets 200% bonus because this is their home turf
	multiply_temp_variable  = { temp_avg_hp_stealth = 2 }

	log = "EXECTUING DETECTION CHECK"
	log = "AVG. FELLOWSHIP STEALTH SKILL: [?temp_avg_fs_stealth]"
	log = "AVG. HUNTING PARTY STEALTH SKILL: [?temp_avg_hp_stealth]"

	# Check which side wins:
	random_list = {
		var:temp_avg_fs_stealth = {
			# Fellowship wins -> remains undetected
			set_temp_variable = { fs_interception_cancelled = 1 }

			log = "DETECTION FAILED"
		}
		var:temp_avg_hp_stealth = {
			# Hunting pary wins -> fellowship located -> interception proceeds

			log = "DETECTION SUCCESSFUL"
		}
	}
}


# Runs a single attempt at intercepting the ring
# Attempts generally follow this loop: combat -> attempt to seize the ring -> disengage or repeat
ring_interception_single_attempt = {

	log = "EXECUTING ATTEMPT [?temp_attempt]"

	ring_interception_execute_combat = yes

	#ring_interception_try_seize = yes

	#ring_interception_disengage_check = yes
}


# combat of temp_attacker trying to attack temp_defender
ring_combat_execute_attack = {

	log = "[?temp_attacker.GetName] attacks [?temp_defender.GetName]"

	# Get defender dexterity
	var:temp_defender = {

		set_temp_variable = { temp_defender_dex = logistics_level }
	}

	# Dex check
	random_list = {
		1 = {
			log = "Attack hits"
			ring_combat_deal_damage = yes
		}
		temp_defender_dex = {
			log = "Attack misses"
		}
	}	
}


ring_combat_deal_damage = {
	# Get attack attack
	var:temp_attacker = {

		set_temp_variable = { temp_attacker_attack = attack_level }
	}

	# subtract from health
	var:temp_defender = {
		log = "HEALTH LEFT: [?health]"


		subtract_from_variable = { health = temp_attacker_attack }

		log = "[?temp_attacker_attack] DAMAGE DEALT TO [?temp_defender.GetName]. HEALTH LEFT: [?health]"

		# check for death
		if = {
			limit = {
				check_variable = { health < 1 }
			}
			ring_combat_kill_character = yes
		}
	}
}

ring_combat_kill_character = {
	log = "[?THIS.GetName] has died."

	ring_remove_member_from_hunting_party = yes
	ring_remove_member_from_fellowship = yes
}


ring_interception_execute_combat = {
	
	# select random member from hunting party
    random_scope_in_array = {
	    array = ROOT.fs_hunting_party
	    
	    set_temp_variable = { temp_attacker = THIS }
    }

    # select random member from fellowship
    random_scope_in_array = {
	    array = global.fs_members
	    
	    set_temp_variable = { temp_defender = THIS }
    }

    #log = "ATTACKER: [?temp_attacker.GetName]"
    #log = "DEFENDER: [?temp_defender.GetName]"

    ring_combat_execute_attack = yes


	# fellowship counter-attacks
	#random_scope_in_array = {
	#    array = global.fs_members
	#    
	#    # TODO: deal damage to hunting party
    #}

    # check/update dead members
}


ring_interception_try_seize = {
	
}


ring_interception_disengage_check = {
	
}