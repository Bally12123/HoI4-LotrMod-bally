

# Clears the current queue of states the fellowship will travel through (the pathstack)
ring_clear_pathstack = {

	clear_array = global.fs_path_stack
}


# Sets the health of all fellowship members to their max-health
ring_heal_fellowship = {
	SHI = {
		for_each_scope_loop = {
		    array = global.fs_members
		    
		    ring_heal_fellowship_member = yes
		}
	}
}


# Opens/Closes the details view
ring_toggle_details_view = {
	if = {
		limit = { has_country_flag = ring_details_view_open }
		clr_country_flag = ring_details_view_open
	}
	# To keep the UI clean and smooth, we won't allow this to open when interception_form is open
	else_if = {
		limit = { NOT = { has_country_flag = ring_interception_form_open } }
		set_country_flag = ring_details_view_open
	}
}


# Sets the health of a fellowship member to their max-health
ring_heal_fellowship_member = {
	THIS = { set_variable = { health = army_defense_level } }
}


# Ensures that the evenlog is no longer than 25 entries, removinmg older entries first
ring_trim_eventlog = {

	while_loop_effect = {
	    limit = { check_variable = { global.fs_eventlog_prefix_targets^num > 25 } }
	    remove_from_array = { array = global.fs_eventlog_prefix_targets index = 0 }
	}

	while_loop_effect = {
	    limit = { check_variable = { global.fs_eventlog_suffix_targets^num > 25 } }
	    remove_from_array = { array = global.fs_eventlog_suffix_targets index = 0 }
	}

	while_loop_effect = {
	    limit = { check_variable = { global.fs_eventlog^num > 25 } }
	    remove_from_array = { array = global.fs_eventlog index = 0 }
	}
}


# Adds the current scope as a member of the fellowship
ring_add_member_to_fellowship = {

	if = {
		limit = { check_variable = { global.fs_members^num < 12 } } # Do not allow more than 12 members. the UI won't work.

		add_to_array = { global.fs_eventlog_prefix_targets = THIS }
		add_to_array = { global.fs_eventlog_suffix_targets = 0 }
		add_to_array = { global.fs_eventlog = token:fs_event_member_joins }
		ring_trim_eventlog = yes

		ring_add_member_to_fellowship_nolog = yes
	}
}


# Adds the current scope as a member of the hunting party of ROOT
ring_toggle_member_to_hunting_party = {

	if = {
		limit = { NOT = { has_character_flag = fs_assigned_to_hunting_party } }
		ring_add_member_to_hunting_party = yes
	}
	else = {
		ring_remove_member_from_hunting_party = yes
	}
}


# Adds the current scope as a member of the hunting party of ROOT
ring_add_member_to_hunting_party = {

	if = {
		limit = {
			THIS = { check_variable = { isdead = 0 } }					# dont assign dead people
			NOT = { has_character_flag = fs_assigned_to_hunting_party } # dont assign twice
		}

		# Set this characters starting HP
		THIS = { set_variable = { health = army_defense_level } }
		THIS = { set_variable = { isdead = 0 } }

		add_to_array = { ROOT.fs_hunting_party = THIS }

		set_character_flag = fs_assigned_to_hunting_party
	}
}


# Adds the current scope as a member of the fellowship, but does NOT log this to the eventlog
ring_add_member_to_fellowship_nolog = {

	if = {
		limit = { check_variable = { global.fs_members^num < 12 } }  # Do not allow more than 12 members. the UI won't work.

		# Set this characters starting vars
		THIS = { set_variable = { health = army_defense_level } }
		THIS = { set_variable = { isdead = 0 } }

		add_to_array = { global.fs_members = THIS }
	}
}


# Removes the current scope from the fellowship
ring_remove_member_from_fellowship = {

	if = {
		limit = { ring_is_fs_member = yes }

		add_to_array = { global.fs_eventlog_prefix_targets = THIS }
		add_to_array = { global.fs_eventlog_suffix_targets = 0 }
		add_to_array = { global.fs_eventlog = token:fs_event_member_leaves }
		ring_trim_eventlog = yes
		
		remove_from_array = { global.fs_members = THIS }
	}
}


# Removes the current scope from the fellowship, but does NOT log this to the eventlog
ring_remove_member_from_fellowship_nolog = {

	remove_from_array = { global.fs_members = THIS }
}


# Removes the current scope from the hunting party of ROOT
ring_remove_member_from_hunting_party = {

	remove_from_array = { ROOT.fs_hunting_party = THIS }

	clr_character_flag = fs_assigned_to_hunting_party
}


# Clears all members from the fellowship, does NOT add an entry to the eventlog
ring_clear_fellowship_members = {

	clear_array = global.fs_members
}


# Checks if all three (MIR, ERE, GON) have responded and the fellowship has fully formed
# If yes, it will call event fs.1002
ring_check_if_council_of_elrond_concluded = {

	if = {
		limit = {
			has_global_flag = fs_mirkwood_responded
			has_global_flag = fs_gondor_responded
			has_global_flag = fs_erebor_responded
		}
		SHI = { country_event = fs.1002 }
	}
}


# Clears the hunting party of ROOT
ring_clear_hunting_party = {

	clear_array = ROOT.fs_hunting_party
}


# Adds an entry to the eventlog stating that the fellowship has arrived in the current scope
ring_log_arrived_in_new_state = {

	add_to_array = { global.fs_eventlog_prefix_targets = 0 }
	add_to_array = { global.fs_eventlog_suffix_targets = THIS }
	add_to_array = { global.fs_eventlog = token:fs_event_arrive_in_new_state }
	ring_trim_eventlog = yes
}


# Queues up an event to move into the next state (fs.1000)
ring_fellowship_begin_move_to_next_state = {

	# TODO: Set this variable based on the speed of the fellowship
	set_variable = { global.fs_days_left_in_state = 7 }
}


# Runs every day. Pls keep as simple as possible for best performance
# Note to self: Maybe make this a weekly update instead?
ring_daily_update = {

	log = "[?global.fs_days_left_in_state]"

	if = {

		# Update fs_days_left_in_state
		limit = { check_variable = { global.fs_days_left_in_state > 0 } }
		subtract_from_variable = { global.fs_days_left_in_state = 1 }

		# When the timer runs out, move fellowship to the enxt state
		if = {
			limit = { check_variable = { global.fs_days_left_in_state = 0 } }

			# This event moves the fellowship to the enxt state
			log = "EXECUTING EVENT FS1000"
			SHI = { country_event = fs.1000 }
		}
	}
}


# Opens up the interception attempt prompt, allowing the country to launch an attempt
ring_open_interception_attempt_prompt = {

	clr_country_flag = ring_details_view_open

	# Only one week to select interception group
	# NOT: do NOT change the 7 day countdown without fixing the GetDayLeftBeforeAutoAbort scripted localization!!
	set_country_flag = {
	    flag = ring_interception_form_open
	    days = 7
	    value = 1
	}
}


# Aborts an interception attempt whilst the prompt is open
ring_abort_interception_attempt = {
	clr_country_flag = ring_interception_form_open

	# TODO: get rid of Cave troll if MOC
}


# Executes an interception attempt by the current scope
ring_execute_interception_attempt = {

	set_temp_variable = { fs_interception_cancelled = 0 }

	# Maximum amount of casualties before disengaging
	set_temp_variable = { fs_interception_max_casualties = ROOT.fs_hunting_party^num }
	multiply_temp_variable = { fs_interception_max_casualties = ROOT.fs_max_casualty_rate }

	# Because its easier to calculate: Min. number of party members to keep fighting
	set_temp_variable = { fs_interception_min_members = ROOT.fs_hunting_party^num }
	subtract_from_temp_variable = { fs_interception_min_members = fs_interception_max_casualties }

	add_to_array = { global.fs_eventlog_prefix_targets = ROOT }
	add_to_array = { global.fs_eventlog_suffix_targets = ROOT.fs_hunting_party^0 }
	add_to_array = { global.fs_eventlog = token:fs_event_tries_to_intercept }
	ring_trim_eventlog = yes

	ring_interception_detection_check = yes

	for_loop_effect = {
	    end = 4
	    value = temp_attempt

	    if = {
			limit = { check_variable = { fs_interception_cancelled = 0 } }

	    	ring_interception_single_attempt = yes
    	}
	}

	# eventlog if fellowship killed the entire hunting party
	if = {
		limit = {
			NOT = { ring_frodo_is_dead = yes }
			check_variable = { ROOT.fs_hunting_party^num < 1 }
		}

		add_to_array = { global.fs_eventlog_prefix_targets = ROOT }
		add_to_array = { global.fs_eventlog_suffix_targets = 0 }
		add_to_array = { global.fs_eventlog = token:fs_event_fellowship_kills_all_enemies }
		ring_trim_eventlog = yes
	}

	# if the for-loop ran to end without cancelling, let the fellowship escape
	else_if = {
		limit = {
			NOT = { ring_frodo_is_dead = yes }
			check_variable = { fs_interception_cancelled = 0 }
		}

		add_to_array = { global.fs_eventlog_prefix_targets = 0 }
		add_to_array = { global.fs_eventlog_suffix_targets = ROOT }
		add_to_array = { global.fs_eventlog = token:fs_event_fellowship_escapes }
		ring_trim_eventlog = yes
	}
}


# Fills the hunting party with all 9 nazgul that are still alive
ring_MOR_set_hunting_party_to_nazgul = {
	MOR = {
		ring_clear_hunting_party = yes

		MOR_Witch_king		= { ring_add_member_to_hunting_party = yes }
		MOR_Khamul			= { ring_add_member_to_hunting_party = yes }
		MOR_Uvantha			= { ring_add_member_to_hunting_party = yes }
		MOR_Hoarmurath		= { ring_add_member_to_hunting_party = yes }
		MOR_Dwar			= { ring_add_member_to_hunting_party = yes }
		MOR_Adunaphel		= { ring_add_member_to_hunting_party = yes }
		MOR_Akhorahil		= { ring_add_member_to_hunting_party = yes }
		MOR_Ji_Indur		= { ring_add_member_to_hunting_party = yes }
		MOR_Ren				= { ring_add_member_to_hunting_party = yes }
	}
}


# Special combat atop the weathertop
ring_execute_weathertop_encounter = {

	# Only Nazgul allowed
	ring_MOR_set_hunting_party_to_nazgul = yes

	add_to_array = { global.fs_eventlog_prefix_targets = 0 }
	add_to_array = { global.fs_eventlog_suffix_targets = 0 }
	add_to_array = { global.fs_eventlog = token:fs_event_weathertop_encounter }
	ring_trim_eventlog = yes

	# Nazgul attack once:
	ring_interception_combat_hp_attack_fs = yes

	# Aragorn gets to attack 3-4 times
    SHI = { FS_aragorn = { set_temp_variable = { temp_attacker = THIS } } }
	random_list = {
		1 = {
			random_scope_in_array = { array = ROOT.fs_hunting_party set_temp_variable = { temp_defender = THIS } }
			ring_combat_execute_attack = yes
			random_scope_in_array = { array = ROOT.fs_hunting_party set_temp_variable = { temp_defender = THIS } }
			ring_combat_execute_attack = yes
			random_scope_in_array = { array = ROOT.fs_hunting_party set_temp_variable = { temp_defender = THIS } }
			ring_combat_execute_attack = yes
		}
		1 = {
			random_scope_in_array = { array = ROOT.fs_hunting_party set_temp_variable = { temp_defender = THIS } }
			ring_combat_execute_attack = yes
			random_scope_in_array = { array = ROOT.fs_hunting_party set_temp_variable = { temp_defender = THIS } }
			ring_combat_execute_attack = yes
			random_scope_in_array = { array = ROOT.fs_hunting_party set_temp_variable = { temp_defender = THIS } }
			ring_combat_execute_attack = yes
			random_scope_in_array = { array = ROOT.fs_hunting_party set_temp_variable = { temp_defender = THIS } }
			ring_combat_execute_attack = yes
		}
	}

	# If Gandalf is with fellowship, he attacks once as well
	if = {
		limit = { SHI = { FS_gandalf = { is_in_array = { global.fs_members = THIS } } } }
		SHI = { FS_gandalf = { set_temp_variable = { temp_attacker = THIS } } }
		random_scope_in_array = { array = ROOT.fs_hunting_party set_temp_variable = { temp_defender = THIS } }
		ring_combat_execute_attack = yes
	}

	# Nazgul attack one more time:
	ring_interception_combat_hp_attack_fs = yes

	# Post-combat:
	if = {
		limit = { NOT = { ring_frodo_is_dead = yes } }

		SHI = {
			# Only Frodo and Arwen press on
			ring_clear_fellowship_members = yes
			FS_frodo = { ring_add_member_to_fellowship_nolog = yes }
			FS_arwen = { ring_add_member_to_fellowship_nolog = yes }

			# eventlog
			add_to_array = { global.fs_eventlog_prefix_targets = 0 }
			add_to_array = { global.fs_eventlog_suffix_targets = 0 }
			add_to_array = { global.fs_eventlog = token:fs_event_arwen_ride }
			ring_trim_eventlog = yes

			# Send Sauron the bad news
			MOR = { country_event = { days = 3 id = mordor.56 } }
		}
	}
}

# Special combat if boromir betrays
ring_execute_boromir_betrayal = {
	SHI = {

		# Remove boromir from fellowship
		FS_boromir = { ring_remove_member_from_fellowship_nolog = yes }

		# Add boromir to hunting party
		ring_clear_hunting_party = yes
		FS_boromir = { ring_add_member_to_hunting_party = yes }

		# execute combat until either boromir or frodo dies (or max attempts)
		for_loop_effect = {
		    end = 6
		    value = temp_attempt

		    if = {
				limit = {
					NOT = {
						ring_boromir_is_dead = yes
						ring_frodo_is_dead = yes
					}
				}

		    	ring_interception_execute_combat = yes
	    	}
		}

		# if frodo dies -> GON seizes ring
		if = {
			limit = { ring_frodo_is_dead = yes }

			GON = { country_event = gondor.11 }
		}
		# if boromir died -> send event to gondor
		else = {
			GON = { country_event = gondor.12 }
		}

		# trigger isengard event (raid)
		# TODO
	}
}

ring_execute_argonath_raid = {
	# if Isengard is bad and exists -> run raid
	if = {
		limit = {
			has_global_flag = gandalf_imprisoned
			country_exists = ISE
		}
		ISE = { country_event = isengard.7 days = 2 }
	}

	# else if Mordor bad and exists -> run raid
	else_if = {
		limit = {
			country_exists = MOR
			NOT = { MOR = { is_subject = yes } }
		}
		MOR = { country_event = isengard.7 days = 2 }
	}

	# else flavour event
	# At least get rid of gandalf, Aragorn, Merry and Pippin, because they are required for other events
	SHI = {
		add_to_array = { global.fs_eventlog_prefix_targets = 0 }
		add_to_array = { global.fs_eventlog_suffix_targets = 0 }
		add_to_array = { global.fs_eventlog = token:fs_event_fellowship_separated }
		ring_trim_eventlog = yes

		FS_gandalf = { ring_remove_member_from_fellowship = yes }
		FS_aragorn = { ring_remove_member_from_fellowship = yes }
		FS_merry = { ring_remove_member_from_fellowship = yes }
		FS_pippin = { ring_remove_member_from_fellowship = yes }
	}
}

# Runs a detection check if ROOT can detect the fellowship
# ARGS: ROOT.fs_hunting_party, global.fs_members
# RETURN: If the check fails, it sets fs_interception_cancelled to 1
ring_interception_detection_check = {

	# Calculate average fellowship stealth skill (planning_skill)
	set_temp_variable = { temp_avg_fs_stealth = 0 }
	for_each_scope_loop = {
	    array = global.fs_members
	    
	    add_to_temp_variable = { temp_avg_fs_stealth = planning_level }
	}
	divide_temp_variable = { temp_avg_fs_stealth = global.fs_members^num }

	# Calculate the average stealth skill of the hunting party
	set_temp_variable = { temp_avg_hp_stealth = 0 }
	for_each_scope_loop = {
	    array = ROOT.fs_hunting_party
	    
	    add_to_temp_variable = { temp_avg_hp_stealth = planning_level }
	}
	divide_temp_variable = { temp_avg_hp_stealth = ROOT.fs_hunting_party^num }
	# Hunting party gets 200% bonus because this is their home turf
	multiply_temp_variable  = { temp_avg_hp_stealth = 2 }

	# Check which side wins:
	random_list = {
		var:temp_avg_fs_stealth = {
			# Fellowship wins -> remains undetected
			set_temp_variable = { fs_interception_cancelled = 1 }

			# Add to eventlog
			add_to_array = { global.fs_eventlog_prefix_targets = ROOT }
			add_to_array = { global.fs_eventlog_suffix_targets = 0 }
			add_to_array = { global.fs_eventlog = token:fs_event_failed_to_locate }
			ring_trim_eventlog = yes
		}
		var:temp_avg_hp_stealth = {
			# Hunting pary wins -> fellowship located -> interception proceeds

			# Add to eventlog
			add_to_array = { global.fs_eventlog_prefix_targets = ROOT }
			add_to_array = { global.fs_eventlog_suffix_targets = 0 }
			add_to_array = { global.fs_eventlog = token:fs_event_managed_to_locate }
			ring_trim_eventlog = yes
		}
	}
}


# Runs a single attempt of ROOT trying to intercept the ring
# Attempts generally follow this loop: combat -> attempt to seize the ring -> disengage or repeat
# ARGS: temp_attempt (attempt number), ROOT.fs_hunting_party, global.fs_members
# RETURN: Sets fs_interception_cancelled to 1 if ring was seized or combat was disengaged
ring_interception_single_attempt = {

	ring_interception_execute_combat = yes

	ring_interception_disengage_check = yes
}


# Runs a single attack of one character onto another
# ARGS: temp_attacker, temp_defender (Attacking and defending characters)
ring_combat_execute_attack = {

	if = {
		# Dont run this if we fucked up with the parameters somewhere
		limit = {
			var:temp_defender = { is_corps_commander = yes }
			var:temp_attacker = { is_corps_commander = yes }
		}

		# Get defender dexterity
		var:temp_defender = {

			set_temp_variable = { temp_defender_dex = logistics_level }
		}

		# Dex check
		random_list = {
			2 = {
				# deal damage (eventlog is taken care of in that function)
				ring_combat_deal_damage = yes
			}
			var:temp_defender_dex = {
				# eventlog: defender dodges attack
				add_to_array = { global.fs_eventlog_prefix_targets = temp_attacker }
				add_to_array = { global.fs_eventlog_suffix_targets = temp_defender }
				add_to_array = { global.fs_eventlog = token:fs_event_char_attacks_char_miss }
				ring_trim_eventlog = yes
			}
		}	
	}
	else = {
		log = "Tried to execute ring_combat_execute_attack, but one of the parameters was not a character."
	}
}


# One character deals damage to another
# Lowers the defenders health by the attackers attack_level. If the health reaches <0, kills the defender
# ARGS: temp_attacker, temp_defender (damage dealer and taker)
ring_combat_deal_damage = {
	if = {
		# Dont run this if we fucked up with the parameters somewhere
		limit = {
			var:temp_defender = { is_corps_commander = yes }
			var:temp_attacker = { is_corps_commander = yes }
		}

		# Get attack attack
		var:temp_attacker = {

			set_temp_variable = { temp_attacker_attack = attack_level }
		}

		# subtract from health
		var:temp_defender = {

			subtract_from_variable = { health = temp_attacker_attack }

			# add damage dealt to eventlog
			if = {
				limit = { var:temp_attacker = { check_variable = { attack_level = 1 } } }
				add_to_array = { global.fs_eventlog_prefix_targets = temp_attacker }
				add_to_array = { global.fs_eventlog_suffix_targets = temp_defender }
				add_to_array = { global.fs_eventlog = token:fs_event_char_attacks_char_1dmg }
				ring_trim_eventlog = yes
			}
			else_if = {
				limit = { var:temp_attacker = { check_variable = { attack_level = 2 } } }
				add_to_array = { global.fs_eventlog_prefix_targets = temp_attacker }
				add_to_array = { global.fs_eventlog_suffix_targets = temp_defender }
				add_to_array = { global.fs_eventlog = token:fs_event_char_attacks_char_2dmg }
				ring_trim_eventlog = yes
			}
			else_if = {
				limit = { var:temp_attacker = { check_variable = { attack_level = 3 } } }
				add_to_array = { global.fs_eventlog_prefix_targets = temp_attacker }
				add_to_array = { global.fs_eventlog_suffix_targets = temp_defender }
				add_to_array = { global.fs_eventlog = token:fs_event_char_attacks_char_3dmg }
				ring_trim_eventlog = yes
			}
			else = {
				add_to_array = { global.fs_eventlog_prefix_targets = temp_attacker }
				add_to_array = { global.fs_eventlog_suffix_targets = temp_defender }
				add_to_array = { global.fs_eventlog = token:fs_event_char_attacks_char_massivedmg }
				ring_trim_eventlog = yes
			}

			# check for death
			if = {
				limit = {
					check_variable = { health < 1 }
				}
				ring_combat_kill_character = yes
			}
		}
	}
	else = {
		log = "Tried to execute ring_combat_execute_attack, but one of the parameters was not a character."
	}
}


# Kills the current scope
# Can be both fellowship or hunting-party member
ring_combat_kill_character = {

	if = {
		limit = { THIS = { check_variable = { isdead = 0 } } } # cant kill someone who is already dead

		# eventlog
		add_to_array = { global.fs_eventlog_prefix_targets = THIS }
		add_to_array = { global.fs_eventlog_suffix_targets = 0 }
		add_to_array = { global.fs_eventlog = token:fs_event_char_dies }
		ring_trim_eventlog = yes

		set_variable = { THIS.isdead = 1 }

		ring_remove_member_from_hunting_party = yes
		ring_remove_member_from_fellowship_nolog = yes

		# This makes the character unusable by everyone
		retire = yes

		# check if frodo is dead
		ring_try_seize = yes
	}
}


# Runs a single combat-instance between fellowship and hunting party
# A combat instance looks like this: random member of hunting party attacks random member from fellowship,
# Then a random fellowship member counter-attacks a random member from the hunting party
# ARGS: ROOT.fs_hunting_party, global.fs_members
# RETURN: Sets fs_interception_cancelled = 1 if either party is empty
ring_interception_execute_combat = {
	
	# Back-and-forth attack
	ring_interception_combat_hp_attack_fs = yes

	ring_interception_combat_fs_attack_hp = yes
}


# Executes a single attack of the hunting party onto the fellowship
ring_interception_combat_hp_attack_fs = {
	# HUNTING PARTY ATTACK
	if = {
		# Only run this if both parties still have people alive
		limit = {
			check_variable = { ROOT.fs_hunting_party^num > 0 }
			check_variable = { global.fs_members^num > 0 }
		}

		# select random member from hunting party
	    random_scope_in_array = {
		    array = ROOT.fs_hunting_party
		    
		    set_temp_variable = { temp_attacker = THIS }
	    }

	    # select random member from fellowship
	    random_scope_in_array = {
		    array = global.fs_members
		    
		    set_temp_variable = { temp_defender = THIS }
	    }

	    ring_combat_execute_attack = yes
    }
    else = {
    	set_temp_variable = { fs_interception_cancelled = 1 }
    }
}


# Executes a single attack of the fellowship onto the hunting party
ring_interception_combat_fs_attack_hp = {
	# FELLOWSHIP COUNTER-ATTACK: (Exactly the same as above but reversed)
    if = {
		# Only run this if both parties still have people alive
		limit = {
			check_variable = { ROOT.fs_hunting_party^num > 0 }
			check_variable = { global.fs_members^num > 0 }
		}

	    # select random member from hunting party
	    random_scope_in_array = {
		    array = global.fs_members
		    
		    set_temp_variable = { temp_attacker = THIS }
	    }

	    # select random member from fellowship
	    random_scope_in_array = {
		    array = ROOT.fs_hunting_party
		    
		    set_temp_variable = { temp_defender = THIS }
	    }

	    ring_combat_execute_attack = yes
    }
    else = {
    	set_temp_variable = { fs_interception_cancelled = 1 }
    }
}


# Runs a single attempt of the hunting party (ROOT) trying to take the ring
# Implementation (for now): You only take the ring of Frodo dies
ring_try_seize = {
	
	if = {
		limit = { ring_frodo_is_dead = yes }

		ring_seize_ring = yes
	}
}


# Runs a single chance at the hunting party disengaging combat with the fellowship
# ARGS: temp_attempt (Attempt number at taking ring)
# RETURN: Sets fs_interception_cancelled = 1 if disengaged
ring_interception_disengage_check = {

	if = {
		# Check if we WANT to disengage in the first place
		limit = { NOT = { check_variable = { ROOT.fs_hunting_party^num > fs_interception_min_members } } }

		random_list = {
			1 = {
				# Disengage fails
			}
			4 = {
				# disengage
				set_temp_variable = { fs_interception_cancelled = 1 }

				# eventlog
				if = {
					limit = { check_variable = { ROOT.fs_hunting_party^num > 0 } }

					add_to_array = { global.fs_eventlog_prefix_targets = ROOT.fs_hunting_party^0 }
					add_to_array = { global.fs_eventlog_suffix_targets = 0 }
					add_to_array = { global.fs_eventlog = token:fs_event_disengages }
					ring_trim_eventlog = yes
				}
			}
		}
	}
}

ring_seize_ring = {
	log = "RING SEIZED"

	# eventlog
	add_to_array = { global.fs_eventlog_prefix_targets = ROOT }
	add_to_array = { global.fs_eventlog_suffix_targets = 0 }
	add_to_array = { global.fs_eventlog = token:fs_event_takes_the_ring }
	ring_trim_eventlog = yes

	# TODO: Actually do something here
	# TODO: trigger notification event for root
	# set flags etc.
	# add/remove ideas
	log = "RING HAS BEEN SEIZED!"
}


# Runs the approprate news event after the fellowship is formed in the council of elrond
ring_execute_fellowship_newspaper_event = {
	if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1000 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1001 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1002 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1010 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1011 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1012 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1020 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1021 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_noone
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1022 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1100 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1101 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1102 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1110 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1111 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1112 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1120 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1121 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_faramir
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1122 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1200 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1201 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_noone
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1202 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1210 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1211 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_tauriel
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1212 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_noone
		}
		news_event = { id = news.1220 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_bombur
		}
		news_event = { id = news.1221 }
	}

	else_if = {
		limit = {
			has_global_flag = fs_gondor_boromir
			has_global_flag = fs_mirkwood_legolas
			has_global_flag = fs_erebor_gimli
		}
		news_event = { id = news.1222 }
	}
}